# ADR-001: Миграция с in-memory на реляционную базу данных
Дата: 2025-10-20
Статус: Accepted

## Context
Текущее in-memory хранилище `_DB` ограничивает возможности сервиса: данные теряются при перезапуске, нет транзакций, сложные запросы невозможны. Риск R4 имеет высокую критичность 15 баллов.

## Decision
Выбрана **SQLite** для быстрого старта. Используем SQLAlchemy ORM для абстракции.

**Технические детали реализации:**
*   **СУБД:** SQLite с файлом `./data/app.db`
*   **ORM:** SQLAlchemy с declarative base
*   **Модели:** `User`, `Habit`, `Checkin`
*   **Миграции:** Используем `Base.metadata.create_all()` для инициализации схемы
*   **Сессии:** Используем `sessionmaker` с зависимостями FastAPI для управления жизненным циклом соединений

## Альтернативные решения
### Вариант 1: PostgreSQL
**Плюсы:**
- Полноценная production-готовая СУБД
- Расширенные возможности: JSONB, полнотекстовый поиск, репликация
- Высокая производительность при больших нагрузках
- Богатая экосистема инструментов мониторинга и бэкапов

**Минусы:**
- Требует отдельного сервера/контейнера
- Сложнее в настройке и администрировании
- Больший overhead для разработки и тестирования
- Дополнительные операционные расходы

### Вариант 2: SQLite (ВЫБРАНО)
**Плюсы:**
- Нулевые зависимости - работает из коробки
- Идеальна для разработки и тестирования
- Простота развертывания - один файл
- Низкие операционные расходы
- Быстрый запуск прототипа

**Минусы:**
- Ограниченная производительность при высоких concurrent нагрузках
- Ограниченные возможности масштабирования
- Нет встроенной репликации


3.  **MongoDB/DocumentDB**
    **Плюсы:**
    - Гибкая схема
    - Хорошая масштабируемость
    - Простота разработки для нереляционных данных.

    ***Минусы:**
    - Отсутствие JOIN-операций усложняет агрегации для статистики
    - Менее строгая валидация данных
    - Не соответствует реляционной природе данных (пользователи-привычки-отметки).

## Consequences
**Плюсы:** Сохранение данных между перезапусками, транзакционная целостность, возможность сложных запросов, быстрый старт
**Минусы:** Ограничения масштабирования, необходимость будущей миграции при росте нагрузки.
**Влияние:** Увеличивает надежность.

## Consequences
### Security Impact
*   **Положительные:** SQLAlchemy предоставляет защиту от SQL-инъекций через параметризованные запросы. Встроенная валидация типов данных на уровне ORM. Транзакции обеспечивают целостность данных.
*   **Отрицательные/Риски:** Файл SQLite требует защиты от несанкционированного доступа. *Мера смягчения: настройка правильных прав доступа к файлу БД.*

### Overall Impact
*   **KPI/SLO:** Увеличивается надежность системы - данные сохраняются между перезапусками. Улучшается целостность данных через транзакционные операции.
*   **Производительность:** Упрощение сложных запросов (статистика по чекинам через JOIN-ы и агрегатные функции)
*   **Разработка:** Появление миграций схемы как новой ответственности

## Rollout Plan

*   **Definition of Done (DoD):**
    1.  Все модели (`User`, `Habit`, `Checkin`) реализованы в SQLAlchemy
    2.  Эндпоинты переписаны с использованием сессий БД
    3.  Написаны тесты
    4.  Старая in-memory реализация полностью удалена

*   **План внедрения:**
    1.  Реализовать модели SQLAlchemy в `models.py`
    2.  Создать модуль `database.py` с настройкой движка и сессий
    3.  Обновить эндпоинты в `main.py` для использования зависимостей БД
    4.  Реализовать инициализацию БД при старте приложения через `lifespan`
    5.  Написать тесты для проверки


## Links
- NFR-04 (Целостность данных)
- R4, F6 из Thread Model
- Тесты в conftest.py, test_health.py
---
